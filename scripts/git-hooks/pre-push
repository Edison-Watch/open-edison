#!/usr/bin/env python3

from __future__ import annotations

import os
import re
import subprocess
import sys
import tomllib  # Python 3.11+

ZERO_SHA = "0000000000000000000000000000000000000000"


def color(text: str, code: str) -> str:
    return f"\033[{code}m{text}\033[0m"


def error(text: str) -> None:
    print(color(text, "0;31"), file=sys.stderr)


def info(text: str) -> None:
    print(color(text, "0;33"))


def ok(text: str) -> None:
    print(color(text, "0;32"))


def run_git(args: list[str], check: bool = True) -> subprocess.CompletedProcess[str]:
    return subprocess.run(["git", *args], capture_output=True, text=True, check=check)


def get_empty_tree() -> str:
    cp = run_git(["hash-object", "-t", "tree", "/dev/null"])
    return cp.stdout.strip()


def get_pyproject_at(commit_sha: str) -> bytes | None:
    try:
        cp = subprocess.run(
            ["git", "show", f"{commit_sha}:pyproject.toml"],
            capture_output=True,
            check=True,
        )
        return cp.stdout
    except subprocess.CalledProcessError:
        return None


def parse_version_toml(pyproject_bytes: bytes) -> tuple[int, int, int] | None:
    # Prefer tomllib for correctness
    data = tomllib.loads(pyproject_bytes.decode("utf-8"))
    version_str = data.get("project", {}).get("version")
    if isinstance(version_str, str):
        m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)", version_str.strip())
        if m:
            return tuple(int(p) for p in m.groups())  # type: ignore[return-value]
    return None


def src_changed(base: str, head: str) -> bool:
    cp = run_git(["diff", "--name-only", f"{base}..{head}", "--", "src/"], check=False)
    return bool(cp.stdout.strip())


def write_text(path: str, content: str) -> None:
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)


def read_text(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def bump_patch_in_pyproject_file(pyproject_path: str) -> tuple[int, int, int] | None:
    text = read_text(pyproject_path)
    pattern = re.compile(
        r'^(version\s*=\s*")(?P<maj>\d+)\.(?P<min>\d+)\.(?P<pat>\d+)("\s*)$', re.MULTILINE
    )
    m = pattern.search(text)
    if not m:
        return None
    maj = int(m.group("maj"))
    min_ = int(m.group("min"))
    pat = int(m.group("pat")) + 1
    # Preserve trailing quote and whitespace (group 5)
    new_text = pattern.sub(rf"\g<1>{maj}.{min_}.{pat}\g<5>", text, count=1)
    write_text(pyproject_path, new_text)
    return (maj, min_, pat)


def git_commit_version_bump(new_version: tuple[int, int, int]) -> bool:
    """Stage pyproject.toml and amend the last commit (fallback to new commit if needed)."""
    version_str = f"{new_version[0]}.{new_version[1]}.{new_version[2]}"
    try:
        run_git(["add", "pyproject.toml"])  # stage version bump
        # Determine if there is an existing commit to amend
        head_ok = subprocess.run(["git", "rev-parse", "--verify", "HEAD"], capture_output=True)
        if head_ok.returncode == 0:
            # Amend last commit without changing the message
            run_git(["commit", "--amend", "--no-edit"])  # keeps message, updates tree
        else:
            # No previous commit; create an initial commit
            run_git(["commit", "-m", f"chore(release): bump version to {version_str} [auto]"])
        return True
    except subprocess.CalledProcessError:
        return False


def enforce_version_bump(local_sha: str, remote_sha: str) -> bool:
    base = remote_sha if remote_sha != ZERO_SHA else get_empty_tree()
    if not src_changed(base, local_sha):
        return True

    info("src/ changed in push range; verifying version bump in pyproject.toml...")

    local_bytes = get_pyproject_at(local_sha)
    if not local_bytes:
        error(f"pyproject.toml not found in commit {local_sha}.")
        return False
    local_ver = parse_version_toml(local_bytes)
    if local_ver is None:
        error(f"Could not parse version from pyproject.toml at {local_sha}.")
        return False

    remote_ver: tuple[int, int, int] | None = None
    if remote_sha != ZERO_SHA:
        remote_bytes = get_pyproject_at(remote_sha)
        if remote_bytes:
            remote_ver = parse_version_toml(remote_bytes)

    # If remote version is unknown (new branch or pyproject missing), allow push
    if remote_ver is None:
        ok(
            f"Version check skipped (no remote version). Local version: {local_ver[0]}.{local_ver[1]}.{local_ver[2]}"
        )
        return True

    lmaj, lmin, lpat = local_ver
    rmaj, rmin, rpat = remote_ver

    # Accept any semver increase (major, minor, or patch)
    if (lmaj, lmin, lpat) > (rmaj, rmin, rpat):
        ok(f"Version bump detected: {rmaj}.{rmin}.{rpat} -> {lmaj}.{lmin}.{lpat}")
        return True

    # Auto-bump patch in working tree and commit it
    pyproject_path = os.path.join(os.getcwd(), "pyproject.toml")
    bumped = bump_patch_in_pyproject_file(pyproject_path)
    if bumped is None:
        error("Version bump required but failed to locate version field in pyproject.toml.")
        return False
    if not git_commit_version_bump(bumped):
        error("Failed to create version bump commit. Please commit manually and push again.")
        return False

    info(
        f"Auto-bumped patch version and amended the last commit: {rmaj}.{rmin}.{rpat} -> {bumped[0]}.{bumped[1]}.{bumped[2]}"
    )
    # Abort current push so the user can push the new commit
    error("Push aborted: version was auto-bumped. Please run git push again.")
    return False


def main() -> int:
    status = 0
    # pre-push receives remote name and remote URL as argv, refs on stdin
    _remote_name = sys.argv[1] if len(sys.argv) > 1 else ""
    _remote_url = sys.argv[2] if len(sys.argv) > 2 else ""

    for line in sys.stdin.read().splitlines():
        if not line.strip():
            continue
        parts = line.split()
        if len(parts) < 4:
            continue
        _, local_sha, _, remote_sha = parts[:4]

        # Skip deletions
        if local_sha == ZERO_SHA:
            continue

        if not enforce_version_bump(local_sha, remote_sha):
            status = 1

    return status


if __name__ == "__main__":
    raise SystemExit(main())
